<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Endure24 Race Timing - The Graveyard Swift</title>
<style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background-color: #c1a0da; /* Background color */
      color: #333; /* Text color */
      font-size: 1rem; /* Base font size */
    }

    h1, h2 {
      color: #5c068c; /* Highlight color for headings */
      font-size: 2rem; /* Scales with the base font size */
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 30px;
      background-color: #fff; /* White background for tables */
      border: 2px solid #5c068c; /* Highlight border */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }

    th {
      background-color: #5c068c; /* Highlight color for table headers */
      color: #fff; /* White text */
    }

    input[type="number"],
    input[type="text"] {
      width: 90%;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    button {
      padding: 6px 12px;
      font-size: 14px;
      height: auto;
      background-color: #5c068c; /* Highlight color for buttons */
      color: #fff; /* White text */
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #4a056e; /* Darker highlight on hover */
    }

    footer {
      margin-top: 40px;
      font-size: 0.9em;
      color: #555;
      text-align: center;
    }

    .completed {
      background-color: #d4edda !important; /* Light green background */
      color: #155724; /* Dark green text */
    }

    .race-header {
      display: flex;
      justify-content: flex-start;
      margin-top: 20px;
      font-size: 1.5em;
      font-weight: bold;
      color: #5c068c; /* Highlight color */
    }

    .greyed-out {
      background-color: #e0e0e0 !important; /* Grey background */
      color: #888; /* Grey text */
    }

    .hidden-table {
      display: none;
    }

    #raceTable thead th {
      position: sticky;
      top: 0;
      background-color: #5c068c; /* Highlight color for sticky headers */
      color: #fff; /* White text */
      z-index: 1;
    }

    .team-container {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      background-color: #c1a0da; /* Background color for team container */
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    #teamPredictions th:first-child,
    #teamPredictions td:first-child {
      width: 120px;
      white-space: nowrap;
    }

    #runnerCountdowns {
      display: flex;
      flex-wrap: wrap; /* Allow items to wrap on smaller screens */
      gap: 10px;
      margin-top: 20px;
      margin-bottom: 20px;
      background-color: #c1a0da; /* Background color for countdowns */
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    .runner-timer {
      flex: 1 1 calc(50% - 10px); /* Adjust width for smaller screens */
      text-align: center;
      background-color: #f4f4f4; /* White background for timers */
      padding: 10px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 1.1em;
      border: 2px solid #5c068c; /* Highlight border */
    }

    .runner-timer.warning {
      background-color: #fff3cd !important; /* Warning background */
    }

    .runner-timer.urgent {
      background-color: #f8d7da !important; /* Urgent background */
    }

    .highlight-current {
      background-color: #fff9c4 !important; /* Yellow background for current lap */
    }

    .next-lap {
      background-color: #f8d7da !important; /* Light red background for next lap */
      color: #721c24; /* Dark red text */
    }

    .on-course {
      background-color: #5c068c !important; /* Highlight color for on-course runner */
      color: #fff; /* White text */
    }

    .on-course-label {
      display: block;
      font-size: 0.9em;
      color: #fff; /* White text */
      margin-top: 6px;
      font-weight: bold;
    }

    .next-to-run {
      background-color: silver !important; /* Silver background for next-to-run */
      color: #333; /* Dark text */
    }

    .next-to-run-label {
      display: block;
      font-size: 0.9em;
      color: #333; /* Dark text */
      margin-top: 6px;
      font-weight: bold;
    }

    @media (max-width: 768px) {
  body {
    padding: 10px; /* Reduce padding for smaller screens */
  }

  table {
    width: 100%; /* Ensure tables fit within the screen */
    font-size: 0.9em; /* Reduce font size for smaller screens */
  }

  .team-container {
    flex-direction: column; /* Stack elements vertically */
    padding: 5px; /* Reduce padding */
  }

  .runner-timer {
    font-size: 0.9em; /* Adjust font size for timers */
    padding: 5px; /* Reduce padding */
  }

  button {
    font-size: 12px; /* Smaller buttons for mobile */
    padding: 4px 8px; /* Adjust button padding */
  }
}
  </style>
</head>
<body onload="loadData()">
{% load static %}
<form style="display: none;">{% csrf_token %}</form>
<span id="fixedLapCount" style="display: none;">{{ fixed_laps }}</span>

<h1>Endure24 Race Timing - The Graveyard Swift</h1>

<span id="cumulativeTime" style="display: none;">{{ cumulative_time }}</span>

<!-- Runner Countdown Section -->
<div id="runnerCountdowns" style="margin-bottom: 20px;">
  <h2>Next Lap Countdown</h2>
  {% for runner in runners %}
  <div class="runner-timer" data-runner-index="{{ forloop.counter0 }}">
    <div class="runner-name-display">{{ runner.name }}</div>
    <div class="runner-countdown-value">--:--:--</div>
    <div class="on-course-label"></div>
    <div class="next-to-run-label"></div>
  </div>
  {% endfor %}
</div>

<!-- Team Predictions Section -->
<div class="team-container">
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1px;">
    <h2 style="margin: 1;">Team Predictions</h2>
    <button onclick="confirmPopulate()">Populate Predictions</button>
    <button onclick="togglePredictionTable()">Hide/Show Team Predictions</button>
  </div>
  <div id="teamPredictionWrapper">
    <div style="margin-bottom: 10px;">
      <label for="lapCount">Lap Rows:</label>
      <input id="lapCount" min="1" onchange="generateLapRows()" style="width: 60px;" type="number" value="30"/>
    </div>
    <table id="teamPredictions" style="width: 80%; margin-top: 0;">
      <thead>
        <tr>
          <th>Runner</th>
          <th>Predicted Minutes</th>
          <th>Predicted Seconds</th>
          <th>D Factor</th>
          <th>Pace</th>
        </tr>
      </thead>
      <tbody>
        {% for runner in runners %}
        <tr>
          <td>
            <select class="runner-dropdown">
              <option value="">Select Runner</option>
              {% for runner_option in runners %}
              <option value="{{ runner_option.name }}">{{ runner_option.name }}</option>
              {% endfor %}
            </select>
          </td>
          <td>
            <input type="number" class="runner-minutes" min="0" placeholder="Minutes">
          </td>
          <td>
            <input type="number" class="runner-seconds" min="0" max="59" placeholder="Seconds">
          </td>
          <td>
            <input type="number" class="runner-dfactor" min="1" step="0.01" placeholder="D Factor" value="1.05">
          </td>
          <td><span class="runner-pace">-</span></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>

<!-- Race Results Section -->
<div class="race-header">Race Results</div>
<table id="raceTable">
  <thead>
    <tr>
      <th>Lap</th>
      <th>Lap Start Time</th>
      <th>Runner</th>
      <th>Laptime</th>
      <th>Pace</th>
      <th>Total Time</th>
      <th>Lap Complete / Fix Predictions</th>
    </tr>
  </thead>
  <tbody>
    {% for lap in laps %}
    <tr class="{% if lap.fixed %}completed{% endif %}" 
    {% if not lap.completed and not lap.runner_field and lap.fixed %}data-fixed-prediction="true"{% endif %}>

      <td>{{ lap.number }}</td>
      <td class="start-time">
        {% if lap.fixed %}
          {{ lap.start_time }}
        {% else %}
          <input type="text" class="start-time-input" value="{{ lap.start_time }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
        {% endif %}
      </td>
      <td>
        {% if lap.fixed %}
          {{ lap.runner }}
        {% else %}
          <input type="text" class="runner-field" value="{{ lap.runner }}" placeholder="Runner">
        {% endif %}
      </td>
      <td>
        {% if lap.fixed %}
          {{ lap.laptime }}
        {% else %}
          <input type="text" class="laptime" value="{{ lap.laptime }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
        {% endif %}
      </td>
      <td class="pace-cell">
        {% if lap.fixed %}
          {{ lap.pace }}
        {% else %}
          <span class="pace-cell">-</span>
        {% endif %}
      </td>
      <td class="total-time">
        {% if lap.fixed %}
          {{ lap.total_time }}
        {% else %}
          <span class="total-time">-</span>
        {% endif %}
      </td>
      <td>
        {% if lap.fixed %}
          <input type="checkbox" class="lap-complete" checked disabled>
        {% else %}
          <input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();">
        {% endif %}
        <input type="checkbox" class="fix-row" onchange="applyFixUpToRow(this)">
      </td>
      
    </tr>
    {% endfor %}
  </tbody>
</table>

<footer>
  <p>Data is saved locally in your browser's localStorage. It will persist across page reloads and browser restarts.</p>
</footer>

<script>
    function parseTime(str) {
      const parts = str.split(":").map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return 0;
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }

    function formatTime(seconds) {
      const hrs = String(Math.floor(seconds / 3600)).padStart(2, '0');
      seconds %= 3600;
      const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
      const secs = String(seconds % 60).padStart(2, '0');
      return `${hrs}:${mins}:${secs}`;
    }

    
function updateTimes() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Day 1 start time: 12:00:00

  const cutoffTime = new Date(baseTime.getTime() + 24 * 3600 * 1000); // 24 hours later: 12:00:00 Day 2

  rows.forEach((row) => {
    const laptimeInput = row.querySelector(".laptime");
    if (!laptimeInput) return;

    const totalTimeCell = row.querySelector(".total-time");
    const startTimeCell = row.querySelector(".start-time");
    const paceCell = row.querySelector(".pace-cell");

    const laptime = parseTime(laptimeInput.value);
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
    startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

    cumulativeSeconds += laptime;
    totalTimeCell.textContent = formatTime(cumulativeSeconds);

    console.log("Cumulative Time (seconds):", cumulativeSeconds);

    if (laptime > 0) {
      const pacePerKm = laptime / 8;
      const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
      const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
      paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
    } else {
      paceCell.textContent = "-";
    }

    // Apply greyed-out class if startTime is after cutoff
    if (startTime > cutoffTime) {
      row.classList.add("greyed-out");
    } else {
      row.classList.remove("greyed-out");
    }
  });
}


    function updatePace(inputEl) {
  const row = inputEl.closest("tr");
  const minutes = row.querySelector(".runner-minutes").value;
  const seconds = row.querySelector(".runner-seconds").value;
  const paceCell = row.querySelector(".runner-pace");

  const totalSeconds = (parseInt(minutes) || 0) * 60 + (parseInt(seconds) || 0);
  if (totalSeconds === 0) {
    paceCell.textContent = "-";
    return;
  }
  const paceSecondsPerKm = totalSeconds / 8; // Assuming 8 km per lap
  const paceMinutes = Math.floor(paceSecondsPerKm / 60);
  const paceSeconds = Math.round(paceSecondsPerKm % 60).toString().padStart(2, '0');
  paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
    }

    function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure?")) {
    populateRunners();
    saveData();
  }
}

    

    function toggleRowCompletion(checkbox) {
      const row = checkbox.closest("tr");
      if (checkbox.checked) {
        row.classList.add("completed"); // Add the "completed" class
        console.log(`Row ${row.rowIndex} marked as completed.`);
      } else {
        row.classList.remove("completed"); // Remove the "completed" class
        console.log(`Row ${row.rowIndex} not completed.`);
      }
    }

    

function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount").value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>${i}</td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td><input type="text" class="runner-field" placeholder="Runner"></td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td><input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();"></td>
    `;
    raceTableBody.appendChild(row);

    // Update cumulative time (default lap time is 0 if not set)
    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
  </script>
<script>
setInterval(updateCountdowns, 1000);
function highlightPreviousLapRow() {
  const now = new Date();
  let closestNegativeDiff = -Infinity;
  let closestRow = null;

  document.querySelectorAll("#raceTable tbody tr").forEach(row => {
    const startTimeCell = row.querySelector(".start-time");
    if (startTimeCell && startTimeCell.textContent.includes(":")) {
      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);
      const start = new Date();
      start.setHours(h, m, s, 0);
      const diff = start - now;
      if (diff < 0 && diff > closestNegativeDiff) {
        closestNegativeDiff = diff;
        closestRow = row;
      }
    }

    // Preserve the "completed" class while removing "highlight-current"
    if (!row.classList.contains("completed")) {
      row.classList.remove("highlight-current");
    }
  });

  if (closestRow) {
    closestRow.classList.add("highlight-current");
  }
}
setInterval(highlightPreviousLapRow, 1000);
function markRunnerOnCourse() {
  const highlightedRow = document.querySelector("#raceTable tbody tr.highlight-current");
  const countdownEls = document.querySelectorAll(".runner-timer");

  // Reset all runners
  countdownEls.forEach((el) => {
    el.classList.remove("on-course");
    el.querySelector(".on-course-label").textContent = "";
  });

  if (highlightedRow) {
    const runnerName = highlightedRow.querySelector(".runner-field")?.value.trim();

    countdownEls.forEach((el) => {
      const displayName = el.querySelector(".runner-name-display").textContent.trim();
      if (runnerName && displayName === runnerName) {
        el.classList.add("on-course");
        el.querySelector(".on-course-label").textContent = "On Course";
      }
    });
  }
}
setInterval(markRunnerOnCourse, 1000);
function markNextRunner() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  let minSeconds = Infinity;
  let nextRunner = null;

  countdownEls.forEach((el) => {
    el.classList.remove("next-to-run");
    el.querySelector(".next-to-run-label").textContent = "";

    const timeStr = el.querySelector(".runner-countdown-value").textContent;
    if (timeStr && timeStr.includes(":")) {
      const [h, m, s] = timeStr.split(":").map(Number);
      const total = h * 3600 + m * 60 + s;
      if (total < minSeconds) {
        minSeconds = total;
        nextRunner = el;
      }
    }
  });

  if (nextRunner) {
    nextRunner.classList.add("next-to-run");
    nextRunner.querySelector(".next-to-run-label").textContent = "Next to Run";
  }
}
setInterval(markNextRunner, 1000);

function updateCountdowns() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const now = new Date();

  // Race start time (today at 12:00:00)
  const raceStart = new Date();
  raceStart.setHours(12, 0, 0, 0);

  countdownEls.forEach((timerEl) => {
    const runnerName = timerEl.querySelector(".runner-name-display").textContent.trim();
    let nextStart = null;

    for (const row of rows) {
      // Get runner for this row
      let rowRunner = "";
      if (row.querySelector(".runner-field")) {
        rowRunner = row.querySelector(".runner-field").value.trim();
      } else {
        rowRunner = row.children[2]?.textContent.trim();
      }

      if (rowRunner !== runnerName) continue;

      // Skip completed laps
      const checkbox = row.querySelector(".lap-complete");
      if (checkbox?.checked) continue;

      // Parse lap start time (hh:mm:ss)
      const startTimeCell = row.querySelector(".start-time");
      if (!startTimeCell || !startTimeCell.textContent.includes(":")) continue;

      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);

      // Construct lap start Date object
      let lapStart = new Date(raceStart);
      lapStart.setHours(h, m, s, 0);

      // If lap time is before race start time (12:00), it means next day
      if (lapStart < raceStart) {
        lapStart.setDate(lapStart.getDate() + 1);
      }

      // If lapStart is in the future, that’s the next lap — break the loop
      if (lapStart > now) {
        nextStart = lapStart;
        break;
      }
    }

    // Update countdown display
    const displayEl = timerEl.querySelector(".runner-countdown-value");
    if (nextStart) {
      const diff = Math.floor((nextStart - now) / 1000);
      const hrs = String(Math.floor(diff / 3600)).padStart(2, "0");
      const mins = String(Math.floor((diff % 3600) / 60)).padStart(2, "0");
      const secs = String(diff % 60).padStart(2, "0");

      displayEl.textContent = `${hrs}:${mins}:${secs}`;
      updateCountdownColors(timerEl, diff);
    } else {
      displayEl.textContent = "--:--:--";
    }
  });
}






function updateCountdownColors(timerEl, secondsLeft) {
  timerEl.classList.remove("urgent", "warning");
  if (secondsLeft < 600) { // Less than 10 minutes
    timerEl.classList.add("urgent");
  } else if (secondsLeft < 1800) { // Less than 30 minutes
    timerEl.classList.add("warning");
  }
}
function togglePredictionTable() {
      const wrapper = document.getElementById("teamPredictionWrapper");
      wrapper.classList.toggle("hidden-table");
    }

function applyCompletedClassOnLoad() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Only toggle .completed for editable checkboxes (i.e., not fixed DB rows)
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });
}



// Call the function on page load
document.addEventListener("DOMContentLoaded", () => {
  applyCompletedClassOnLoad();
});
function saveData() {
  const fixedLaps = parseInt(document.getElementById("fixedLapCount")?.textContent) || 0;

  const data = {
    predictions: Array.from(document.querySelectorAll("#teamPredictions tbody tr")).map(row => {
      const dropdown = row.querySelector(".runner-dropdown");
      const minutes = row.querySelector(".runner-minutes")?.value || 0;
      const seconds = row.querySelector(".runner-seconds")?.value || 0;
      return {
        runner: dropdown?.value || "",
        minutes: parseInt(minutes),
        seconds: parseInt(seconds),
      };
    }),

    race: Array.from(document.querySelectorAll("#raceTable tbody tr")).map((row, index) => {
      const runnerField = row.querySelector(".runner-field");
      const laptimeField = row.querySelector(".laptime");
      const checkbox = row.querySelector(".lap-complete");

      if (!runnerField || !laptimeField) return null;

      return {
        number: fixedLaps + index + 1,  // Offset lap number
        runner: runnerField.value,
        laptime: laptimeField.value,
        complete: checkbox?.checked || false,
        fixed_prediction: row.hasAttribute("data-fixed-prediction") // Add fixed_prediction attribute
      };
    }).filter(row => row !== null)
  };

  fetch('/save-predictions/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value,
    },
    body: JSON.stringify(data),
  })
  .then(response => response.json())
  .then(data => console.log('Save response:', data))
  .catch(error => console.error('Error saving data:', error));

  localStorage.setItem("raceData", JSON.stringify(data));
}

function loadData() {
  const saved = localStorage.getItem("raceData");
  if (!saved) return;
  const data = JSON.parse(saved);

  // Restore team predictions
  const predictionRows = document.querySelectorAll("#teamPredictions tbody tr");
  predictionRows.forEach((row, i) => {
    const dropdown = row.querySelector(".runner-dropdown");
    const minutesInput = row.querySelector(".runner-minutes");
    const secondsInput = row.querySelector(".runner-seconds");

    const savedPrediction = data.predictions[i];
    if (savedPrediction) {
      if (dropdown) dropdown.value = savedPrediction.runner;
      if (minutesInput) minutesInput.value = savedPrediction.minutes;
      if (secondsInput) secondsInput.value = savedPrediction.seconds;

      updatePace(minutesInput); // recalculate pace cell
    }
  });

  // Restore predicted race rows (non-fixed only)
  const raceRows = document.querySelectorAll("#raceTable tbody tr");
  data.race.forEach((lap, i) => {
    const row = raceRows[i];
    if (!row) return;

    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const checkbox = row.querySelector(".lap-complete");

    if (runnerField) runnerField.value = lap.runner;
    if (laptimeField) laptimeField.value = lap.laptime;
    if (checkbox && !checkbox.disabled) {
    checkbox.checked = lap.complete;
}


    // ✅ Only set data-fixed-prediction on editable rows
    if (lap.fixed_prediction && runnerField) {
      row.setAttribute("data-fixed-prediction", "true");
      const fixBox = row.querySelector(".fix-row");
      if (fixBox) fixBox.checked = true;
    }

    // ✅ Only apply .completed class to editable rows
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });

  updateTimes(); // refresh Start Time, Pace, Total Time
}


function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount").value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>${i}</td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td><input type="text" class="runner-field" placeholder="Runner"></td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td><input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();"></td>
    `;
    raceTableBody.appendChild(row);

    // Update cumulative time (default lap time is 0 if not set)
    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure you want to populate predictions?")) {
    populateRunners();
    saveData(); // Ensure saveData is defined elsewhere
  }
}

function populateRunners() {
  const dropdowns = document.querySelectorAll(".runner-dropdown");
  const minuteInputs = document.querySelectorAll(".runner-minutes");
  const secondInputs = document.querySelectorAll(".runner-seconds");
  const dfactorInputs = document.querySelectorAll(".runner-dfactor");

  // Collect predictions from the Team Predictions table
  const runners = Array.from(dropdowns).map((dropdown, index) => {
    return {
      name: dropdown.value.trim(),
      minutes: parseInt(minuteInputs[index].value) || 0,
      seconds: parseInt(secondInputs[index].value) || 0,
      dfactor: parseFloat(dfactorInputs[index].value) || 1, // Default D Factor is 1
      laps: 0 // Track the number of laps for each runner
    };
  }).filter(runner => runner.name); // Filter out empty rows

  console.log("Collected Runners:", runners);

  const raceTableBody = document.querySelector("#raceTable tbody");
  const rows = raceTableBody.querySelectorAll("tr");

  let cumulativeSeconds = parseTime(document.getElementById("cumulativeTime").textContent); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Determine the starting index for predictions
  let startIndex = 0;

  // Check for the last fixed-prediction row
  const lastFixedRow = Array.from(rows).reverse().find(row => row.hasAttribute("data-fixed-prediction"));
  if (lastFixedRow) {
    const lastRunnerName = lastFixedRow.querySelector(".runner-field")?.value.trim();
    startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
    if (startIndex >= runners.length) {
      startIndex = 0; // Wrap around to the beginning
    }
  } else {
    // Fallback to the most recent completed runner if no fixed predictions exist
    const lastCompletedRow = Array.from(rows).reverse().find(row => row.querySelector(".lap-complete")?.checked);
    if (lastCompletedRow) {
      const lastRunnerName = lastCompletedRow.querySelector(".runner-field")?.value.trim();
      startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
      if (startIndex >= runners.length) {
        startIndex = 0; // Wrap around to the beginning
      }
    }
  }

  console.log(`Starting predictions from index: ${startIndex}`);

  let runnerIndex = startIndex; // Start predictions after the last fixed-prediction or completed runner

  rows.forEach((row, index) => {
    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const startTimeCell = row.querySelector(".start-time");
    const totalTimeCell = row.querySelector(".total-time");
    const paceCell = row.querySelector(".pace-cell");
    const checkbox = row.querySelector(".lap-complete");

    if (!checkbox.checked && runnerField && !row.hasAttribute("data-fixed-prediction")) {
      // Only populate rows that are not marked as completed and are not fixed predictions
      const runner = runners[runnerIndex % runners.length];
      if (runner) {
        runnerField.value = runner.name;

        // Calculate lap time
        let lapSeconds = runner.minutes * 60 + runner.seconds;
        if (runner.laps > 0) { // Apply D Factor only for laps after the first
          lapSeconds = Math.round(lapSeconds * runner.dfactor);
        }

        const hh = String(Math.floor(lapSeconds / 3600)).padStart(2, '0');
        const mm = String(Math.floor((lapSeconds % 3600) / 60)).padStart(2, '0');
        const ss = String(lapSeconds % 60).padStart(2, '0');
        laptimeField.value = `${hh}:${mm}:${ss}`;

        // Update cumulative time
        const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
        startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

        cumulativeSeconds += lapSeconds;
        totalTimeCell.textContent = formatTime(cumulativeSeconds);

        // Calculate pace
        if (lapSeconds > 0) {
          const pacePerKm = lapSeconds / 8; // Assuming 8 km per lap
          const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
          const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
          paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
        } else {
          paceCell.textContent = "-";
        }

        // Update runner's predicted time for the next lap
        runner.minutes = Math.floor(lapSeconds / 60);
        runner.seconds = lapSeconds % 60;

        runner.laps++; // Increment the lap count for the runner
        runnerIndex++;
      }
    }
  });

  updateTimes(); // Recalculate times for all rows
}

function highlightNextLapRow() {
  const rows = document.querySelectorAll("#raceTable tbody tr");
  let currentLapFound = false;

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Preserve the "completed" class while removing "next-lap"
    if (!row.classList.contains("completed")) {
      row.classList.remove("next-lap");
    }

    if (row.classList.contains("highlight-current")) {
      currentLapFound = true; // Mark the current lap as found
    } else if (currentLapFound && !checkbox.checked) {
      row.classList.add("next-lap"); // Apply the "next-lap" class to the next lap
      currentLapFound = false; // Stop after marking the next lap
    }
  });
}

// Call the function periodically to update the next lap
setInterval(highlightNextLapRow, 1000);

function applyFixUpToRow(checkbox) {
  const row = checkbox.closest("tr");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const index = rows.indexOf(row);

  rows.forEach((r, i) => {
    if (i <= index) {
      r.setAttribute("data-fixed-prediction", "true");
      const fixBox = r.querySelector(".fix-row");
      if (fixBox) fixBox.checked = true;
    } else {
      r.removeAttribute("data-fixed-prediction");
      const fixBox = r.querySelector(".fix-row");
      if (fixBox) fixBox.checked = false;
    }
  });

  saveData();
}

</script>
<script src="{% static 'e24_app/js/live_results.js' %}"></script>
</body>
</html>
