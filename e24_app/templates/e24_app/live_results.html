<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Endure24 Race Timing - The Graveyard Swift</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 20px;
    background-color: #111; /* Black background */
    color: #e6e6e6; /* Light text */
    font-size: 1rem;
  }

  h1, h2 {
    color: #fff; /* White headings for contrast */
    font-size: 2rem;
    text-shadow: 0 2px 8px #5c068c;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 30px;
    background-color: #181828; /* Very dark for tables */
    border: 2px solid #5c068c; /* Purple outline */
    box-shadow: 0 4px 16px rgba(92,6,140,0.2);
  }

  th, td {
    border: 1px solid #5c068c; /* Purple cell borders */
    padding: 8px;
    text-align: center;
  }

  th {
    background-color: #181828;
    color: #c1a0da;
    border-bottom: 2px solid #5c068c;
  }

  input[type="number"],
  input[type="text"] {
    width: 90%;
    padding: 4px;
    border: 1px solid #5c068c;
    border-radius: 4px;
    background: #181828;
    color: #e6e6e6;
  }

  select {
    background: #181828;
    color: #e6e6e6;
    border: 1px solid #5c068c;
    border-radius: 4px;
    padding: 4px;
  }

  button {
    padding: 6px 12px;
    font-size: 14px;
    height: auto;
    background-color: #181828;
    color: #c1a0da;
    border: 2px solid #5c068c;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(92,6,140,0.2);
    transition: background 0.2s, color 0.2s;
  }

  button:hover {
    background-color: #5c068c;
    color: #fff;
  }

  footer {
    margin-top: 40px;
    font-size: 0.9em;
    color: #aaa;
    text-align: center;
  }

  .completed {
    background-color: #223c2a !important; /* Muted green for completed */
    color: #b6f7c1;
  }

  .race-header {
    display: flex;
    justify-content: flex-start;
    margin-top: 20px;
    font-size: 1.5em;
    font-weight: bold;
    color: #fff;
    border-left: 6px solid #5c068c;
    padding-left: 12px;
  }

  .greyed-out {
    background-color: #222 !important;
    color: #888;
  }

  .hidden-table {
    display: none;
  }

  #raceTable thead th {
    position: sticky;
    top: 0;
    background-color: #181828;
    color: #fff;
    z-index: 1;
    border-bottom: 2px solid #5c068c;
  }

  .team-container {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    background-color: #181828;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(92,6,140,0.2);
    border: 2px solid #5c068c;
  }

  #teamPredictions th:first-child,
  #teamPredictions td:first-child {
    width: 120px;
    white-space: nowrap;
  }

  #runnerCountdowns {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 20px;
    margin-bottom: 20px;
    background-color: #181828;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(92,6,140,0.2);
    border: 2px solid #5c068c;
    flex-direction: row; /* Ensure horizontal layout by default */
    align-items: stretch;
  }

  .runner-timer {
    flex: 1 1 220px;
    min-width: 180px;
    max-width: 320px;
    margin: 0 5px;
    text-align: center;
    background-color: #181828;
    padding: 10px;
    border-radius: 8px;
    font-weight: bold;
    font-size: 1.1em;
    border: 2px solid #5c068c;
    color: #e6e6e6;
  }

  .runner-timer.warning {
    background-color: #bfae5e !important;
    color: #2a203a;
  }

  .runner-timer.urgent {
    background-color: #a34d5c !important;
    color: #fff;
  }

  .highlight-current {
    background-color:  #5c068c !important;
    color: #fff;
    border-left: 4px solid #5c068c;
  }

  .next-lap {
    background-color: #a34d5c !important;
    color: #fff;
  }

  .on-course {
    background-color: #5c068c !important;
    color: #fff;
  }

  .on-course-label {
    display: block;
    font-size: 0.9em;
    color: #fff;
    margin-top: 6px;
    font-weight: bold;
  }

  .next-to-run {
    background-color: #bbb !important;
    color: #2a203a;
    border: 2px solid #5c068c;
  }

  .next-to-run-label {
    display: block;
    font-size: 0.9em;
    color: #2a203a;
    margin-top: 6px;
    font-weight: bold;
  }

  /* Scrollbar styling for dark mode */
  ::-webkit-scrollbar {
    width: 10px;
    background: #181828;
  }
  ::-webkit-scrollbar-thumb {
    background: #5c068c;
    border-radius: 5px;
  }

  @media (max-width: 768px) {
    body {
      padding: 10px;
    }
    table {
      width: 100%;
      font-size: 0.9em;
    }
    .team-container {
      flex-direction: column;
      padding: 5px;
    }
    .runner-timer {
      font-size: 0.9em;
      padding: 5px;
    }
    button {
      font-size: 12px;
      padding: 4px 8px;
    }
  }

  /* Stack vertically on small screens */
  @media (max-width: 900px) {
    #runnerCountdowns {
      flex-direction: column;
      align-items: stretch;
    }
    .runner-timer {
      max-width: 100%;
      margin: 5px 0;
    }
  }
</style>
</head>
<body onload="loadData()">
{% load static %}
<form style="display: none;">{% csrf_token %}</form>
<span id="fixedLapCount" style="display: none;">{{ fixed_laps }}</span>

<h1>Endure24 Race Timing - The Graveyard Swift</h1>

<span id="cumulativeTime" style="display: none;">{{ cumulative_time }}</span>

<!-- Runner Countdown Section -->
<div id="runnerCountdowns" style="margin-bottom: 20px;">
  <h2>Next Lap Countdown</h2>
  {% for runner in runners %}
  <div class="runner-timer" data-runner-index="{{ forloop.counter0 }}">
    <div class="runner-name-display">{{ runner.name }}</div>
    <div class="runner-countdown-value">--:--:--</div>
    <div class="on-course-label"></div>
    <div class="next-to-run-label"></div>
  </div>
  {% endfor %}
</div>

<!-- Team Predictions Section -->
<div class="team-container">
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1px;">
    <h2 style="margin: 1;">Team Predictions</h2>
    <button type="button" onclick="confirmPopulate()">Populate Predictions</button>
    <button onclick="togglePredictionTable()">Hide/Show Team Predictions</button>
  </div>
  <div id="teamPredictionWrapper">
    <div style="margin-bottom: 10px;">
      <label for="lapCount">Lap Rows:</label>
      <input id="lapCount" min="1" onchange="generateLapRows(); saveData();" style="width: 60px;" type="number" value="30"/>
    </div>
    <table id="teamPredictions" style="width: 80%; margin-top: 0;">
      <thead>
        <tr>
          <th>Runner</th>
          <th>Predicted Minutes</th>
          <th>Predicted Seconds</th>
          <th>D Factor</th>
          <th>Pace (first lap)</th>
          <th>Time Lost (sec/lap)</th>
        </tr>
      </thead>
      <tbody>
        {% for runner in runners %}
        <tr>
          <td>
            <select class="runner-dropdown" onchange="saveData();">
              <option value="">Select Runner</option>
              {% for runner_option in runners %}
              <option value="{{ runner_option.name }}">{{ runner_option.name }}</option>
              {% endfor %}
            </select>
          </td>
          <td>
            <input type="number" class="runner-minutes" min="0" placeholder="Minutes" oninput="updatePace(this); saveData();">
          </td>
          <td>
            <input type="number" class="runner-seconds" min="0" max="59" placeholder="Seconds" oninput="updatePace(this); saveData();">
          </td>
          <td>
            <input type="number" class="runner-dfactor" min="1" step="0.01" placeholder="D Factor" value="1.05" oninput="updatePace(this); saveData();">
          </td>
          <td><span class="runner-pace">-</span></td>
          <td><span class="runner-time-lost">-</span></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>

<!-- Race Results Section -->
<div class="race-header">Race Results</div>
<table id="raceTable">
  <thead>
    <tr>
      <th>Lap</th>
      <th>Lap Start Time</th>
      <th>Runner</th>
      <th>Laptime</th>
      <th>Pace</th>
      <th>Total Time</th>
      <th>Lap Complete / Fix Predictions</th>
    </tr>
  </thead>
  <tbody>
    {% for lap in laps %}
    {% if lap.fixed %}
      <tr class="completed">
        <td>{{ lap.number }}</td>
        <td class="start-time">
          {% if lap.fixed %}
            {{ lap.start_time }}
          {% else %}
            <input type="text" class="start-time-input" value="{{ lap.start_time }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
          {% endif %}
        </td>
        <td>
          {% if lap.fixed %}
            {{ lap.runner }}
          {% else %}
            <input type="text" class="runner-field" value="{{ lap.runner }}" placeholder="Runner">
          {% endif %}
        </td>
        <td>
          {% if lap.fixed %}
            {{ lap.laptime }}
          {% else %}
            <input type="text" class="laptime" value="{{ lap.laptime }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
          {% endif %}
        </td>
        <td class="pace-cell">
          {% if lap.fixed %}
            {{ lap.pace }}
          {% else %}
            <span class="pace-cell">-</span>
          {% endif %}
        </td>
        <td class="total-time">
          {% if lap.fixed %}
            {{ lap.total_time }}
          {% else %}
            <span class="total-time">-</span>
          {% endif %}
        </td>
        <td>
          {% if lap.fixed %}
            <input type="checkbox" class="lap-complete" checked disabled>
          {% else %}
            <input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();">
          {% endif %}
          <input type="checkbox" class="fix-row" onchange="applyFixUpToRow(this)">
        </td>
        
      </tr>
    {% endif %}
    {% endfor %}
  </tbody>
</table>

<footer>
  <p>Data is saved locally in your browser's localStorage. It will persist across page reloads and browser restarts.</p>
</footer>

<script>
    function parseTime(str) {
      const parts = str.split(":").map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return 0;
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }

    function formatTime(seconds) {
      const hrs = String(Math.floor(seconds / 3600)).padStart(2, '0');
      seconds %= 3600;
      const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
      const secs = String(seconds % 60).padStart(2, '0');
      return `${hrs}:${mins}:${secs}`;
    }

    
function updateTimes() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Day 1 start time: 12:00:00

  const cutoffTime = new Date(baseTime.getTime() + 24 * 3600 * 1000); // 24 hours later: 12:00:00 Day 2

  rows.forEach((row) => {
    const laptimeInput = row.querySelector(".laptime");
    if (!laptimeInput) return;

    const totalTimeCell = row.querySelector(".total-time");
    const startTimeCell = row.querySelector(".start-time");
    const paceCell = row.querySelector(".pace-cell");

    const laptime = parseTime(laptimeInput.value);
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
    startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

    cumulativeSeconds += laptime;
    totalTimeCell.textContent = formatTime(cumulativeSeconds);

    console.log("Cumulative Time (seconds):", cumulativeSeconds);

    if (laptime > 0) {
      const pacePerKm = laptime / 8;
      const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
      const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
      paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
    } else {
      paceCell.textContent = "-";
    }

    // Apply greyed-out class if startTime is after cutoff
    if (startTime > cutoffTime) {
      row.classList.add("greyed-out");
    } else {
      row.classList.remove("greyed-out");
    }
  });
}


    function updatePace(inputEl) {
  const row = inputEl.closest("tr");
  const minutes = parseInt(row.querySelector(".runner-minutes").value) || 0;
  const seconds = parseInt(row.querySelector(".runner-seconds").value) || 0;
  const dfactor = parseFloat(row.querySelector(".runner-dfactor").value) || 1;
  const paceCell = row.querySelector(".runner-pace");
  const timeLostCell = row.querySelector(".runner-time-lost");

  // Calculate original lap time in seconds (no D-Factor)
  let baseSeconds = minutes * 60 + seconds;
  if (baseSeconds === 0) {
    paceCell.textContent = "-";
    timeLostCell.textContent = "-";
    return;
  }

  // Pace per km (no D-Factor)
  const paceSecondsPerKm = baseSeconds / 8;
  const paceMinutes = Math.floor(paceSecondsPerKm / 60);
  const paceSeconds = Math.round(paceSecondsPerKm % 60).toString().padStart(2, '0');
  paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;

  // Time lost per lap due to D-Factor
  const dLapSeconds = Math.round(baseSeconds * dfactor);
  const timeLost = dLapSeconds - baseSeconds;
  timeLostCell.textContent = timeLost > 0 ? `+${timeLost}` : "0";
}
    function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure you want to populate predictions?")) {
    populateRunners();
    saveData();
    loadData(); // <-- Add this line if you want to force a UI refresh
  }
}

    

    function toggleRowCompletion(checkbox) {
      const row = checkbox.closest("tr");
      if (checkbox.checked) {
        row.classList.add("completed"); // Add the "completed" class
        console.log(`Row ${row.rowIndex} marked as completed.`);
      } else {
        row.classList.remove("completed"); // Remove the "completed" class
        console.log(`Row ${row.rowIndex} not completed.`);
      }
    }

    

function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>${i}</td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td><input type="text" class="runner-field" placeholder="Runner"></td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td><input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();"></td>
    `;
    raceTableBody.appendChild(row);

    // Update cumulative time (default lap time is 0 if not set)
    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
  </script>
<script>
setInterval(updateCountdowns, 1000);
function highlightPreviousLapRow() {
  const now = new Date();
  let closestNegativeDiff = -Infinity;
  let closestRow = null;

  document.querySelectorAll("#raceTable tbody tr").forEach(row => {
    const startTimeCell = row.querySelector(".start-time");
    if (startTimeCell && startTimeCell.textContent.includes(":")) {
      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);
      const start = new Date();
      start.setHours(h, m, s, 0);
      const diff = start - now;
      if (diff < 0 && diff > closestNegativeDiff) {
        closestNegativeDiff = diff;
        closestRow = row;
      }
    }

    // Preserve the "completed" class while removing "highlight-current"
    if (!row.classList.contains("completed")) {
      row.classList.remove("highlight-current");
    }
  });

  if (closestRow) {
    closestRow.classList.add("highlight-current");
  }
}
setInterval(highlightPreviousLapRow, 1000);
function markRunnerOnCourse() {
  const highlightedRow = document.querySelector("#raceTable tbody tr.highlight-current");
  const countdownEls = document.querySelectorAll(".runner-timer");

  // Reset all runners
  countdownEls.forEach((el) => {
    el.classList.remove("on-course");
    el.querySelector(".on-course-label").textContent = "";
  });

  if (highlightedRow) {
    const runnerName = highlightedRow.querySelector(".runner-field")?.value.trim();

    countdownEls.forEach((el) => {
      const displayName = el.querySelector(".runner-name-display").textContent.trim();
      if (runnerName && displayName === runnerName) {
        el.classList.add("on-course");
        el.querySelector(".on-course-label").textContent = "On Course";
      }
    });
  }
}
setInterval(markRunnerOnCourse, 1000);
function markNextRunner() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  let minSeconds = Infinity;
  let nextRunner = null;

  countdownEls.forEach((el) => {
    el.classList.remove("next-to-run");
    el.querySelector(".next-to-run-label").textContent = "";

    const timeStr = el.querySelector(".runner-countdown-value").textContent;
    if (timeStr && timeStr.includes(":")) {
      const [h, m, s] = timeStr.split(":").map(Number);
      const total = h * 3600 + m * 60 + s;
      if (total < minSeconds) {
        minSeconds = total;
        nextRunner = el;
      }
    }
  });

  if (nextRunner) {
    nextRunner.classList.add("next-to-run");
    nextRunner.querySelector(".next-to-run-label").textContent = "Next to Run";
  }
}
setInterval(markNextRunner, 1000);

function updateCountdowns() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const now = new Date();

  // Race start time (today at 12:00:00)
  const raceStart = new Date();
  raceStart.setHours(12, 0, 0, 0);

  countdownEls.forEach((timerEl) => {
    const runnerName = timerEl.querySelector(".runner-name-display").textContent.trim();
    let nextStart = null;

    for (const row of rows) {
      // Get runner for this row
      let rowRunner = "";
      if (row.querySelector(".runner-field")) {
        rowRunner = row.querySelector(".runner-field").value.trim();
      } else {
        rowRunner = row.children[2]?.textContent.trim();
      }

      if (rowRunner !== runnerName) continue;

      // Skip completed laps
      const checkbox = row.querySelector(".lap-complete");
      if (checkbox?.checked) continue;

      // Parse lap start time (hh:mm:ss)
      const startTimeCell = row.querySelector(".start-time");
      if (!startTimeCell || !startTimeCell.textContent.includes(":")) continue;

      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);

      // Construct lap start Date object
      let lapStart = new Date(raceStart);
      lapStart.setHours(h, m, s, 0);

      // If lap time is before race start time (12:00), it means next day
      if (lapStart < raceStart) {
        lapStart.setDate(lapStart.getDate() + 1);
      }

      // If lapStart is in the future, that’s the next lap — break the loop
      if (lapStart > now) {
        nextStart = lapStart;
        break;
      }
    }

    // Update countdown display
    const displayEl = timerEl.querySelector(".runner-countdown-value");
    if (nextStart) {
      const diff = Math.floor((nextStart - now) / 1000);
      const hrs = String(Math.floor(diff / 3600)).padStart(2, "0");
      const mins = String(Math.floor((diff % 3600) / 60)).padStart(2, "0");
      const secs = String(diff % 60).padStart(2, "0");

      displayEl.textContent = `${hrs}:${mins}:${secs}`;
      updateCountdownColors(timerEl, diff);
    } else {
      displayEl.textContent = "--:--:--";
    }
  });
}






function updateCountdownColors(timerEl, secondsLeft) {
  timerEl.classList.remove("urgent", "warning");
  if (secondsLeft < 600) { // Less than 10 minutes
    timerEl.classList.add("urgent");
  } else if (secondsLeft < 1800) { // Less than 30 minutes
    timerEl.classList.add("warning");
  }
}
function togglePredictionTable() {
      const wrapper = document.getElementById("teamPredictionWrapper");
      wrapper.classList.toggle("hidden-table");
    }

function applyCompletedClassOnLoad() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Only toggle .completed for editable checkboxes (i.e., not fixed DB rows)
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });
}



// Call the function on page load
document.addEventListener("DOMContentLoaded", () => {
  applyCompletedClassOnLoad();
});
function saveData() {
  const fixedLaps = parseInt(document.getElementById("fixedLapCount")?.textContent) || 0;
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;

  // Only save editable rows (those with .runner-field)
  const editableRows = Array.from(document.querySelectorAll("#raceTable tbody tr"))
    .filter(row => row.querySelector(".runner-field"));

  const data = {
    lapCount: lapCount,
    predictions: Array.from(document.querySelectorAll("#teamPredictions tbody tr")).map(row => {
      const dropdown = row.querySelector(".runner-dropdown");
      const minutes = row.querySelector(".runner-minutes")?.value || 0;
      const seconds = row.querySelector(".runner-seconds")?.value || 0;
      const dfactor = row.querySelector(".runner-dfactor")?.value || 1;
      return {
        runner: dropdown?.value || "",
        minutes: parseInt(minutes),
        seconds: parseInt(seconds),
        dfactor: parseFloat(dfactor)
      };
    }),
    race: editableRows.map((row, index) => {
      const runnerField = row.querySelector(".runner-field");
      const laptimeField = row.querySelector(".laptime");
      const checkbox = row.querySelector(".lap-complete");

      if (!runnerField || !laptimeField) return null;

      return {
        number: fixedLaps + index + 1,  // Offset lap number
        runner: runnerField.value,
        laptime: laptimeField.value,
        complete: checkbox?.checked || false,
        fixed_prediction: row.hasAttribute("data-fixed-prediction")
      };
    }).filter(row => row !== null)
  };

  localStorage.setItem("raceData", JSON.stringify(data));
}

function loadData() {
  const saved = localStorage.getItem("raceData");
  if (!saved) return;
  const data = JSON.parse(saved);

  // Restore lap count and generate rows
  if (data.lapCount) {
    const lapCountInput = document.getElementById("lapCount");
    if (lapCountInput) {
      lapCountInput.value = data.lapCount;
      generateLapRows(); // Ensure correct number of rows before restoring race data
    }
  }

  // Restore team predictions
  const predictionRows = document.querySelectorAll("#teamPredictions tbody tr");
  predictionRows.forEach((row, i) => {
    const dropdown = row.querySelector(".runner-dropdown");
    const minutesInput = row.querySelector(".runner-minutes");
    const secondsInput = row.querySelector(".runner-seconds");
    const dfactorInput = row.querySelector(".runner-dfactor");

    const savedPrediction = data.predictions[i];
    if (savedPrediction) {
      if (dropdown) dropdown.value = savedPrediction.runner;
      if (minutesInput) minutesInput.value = savedPrediction.minutes;
      if (secondsInput) secondsInput.value = savedPrediction.seconds;
      if (dfactorInput) dfactorInput.value = savedPrediction.dfactor;
      updatePace(minutesInput); // recalculate pace cell
    }
  });

  // Restore predicted race rows (skip fixed rows)
  const raceRows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  // Only editable rows (those with .runner-field input)
  const editableRows = raceRows.filter(row => row.querySelector(".runner-field"));

  data.race.forEach((lap, i) => {
    const row = editableRows[i];
    if (!row) return;

    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const checkbox = row.querySelector(".lap-complete");

    if (runnerField) runnerField.value = lap.runner;
    if (laptimeField) laptimeField.value = lap.laptime;
    if (checkbox && !checkbox.disabled) {
      checkbox.checked = lap.complete;
    }

    // Only set data-fixed-prediction on editable rows
    if (lap.fixed_prediction && runnerField) {
      row.setAttribute("data-fixed-prediction", "true");
      const fixBox = row.querySelector(".fix-row");
      if (fixBox) fixBox.checked = true;
    }

    // Only apply .completed class to editable rows
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });

  updateTimes(); // refresh Start Time, Pace, Total Time
}


function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>${i}</td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td><input type="text" class="runner-field" placeholder="Runner"></td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td><input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();"></td>
    `;
    raceTableBody.appendChild(row);

    // Update cumulative time (default lap time is 0 if not set)
    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure you want to populate predictions?")) {
    populateRunners();
    saveData();
    loadData(); // <-- Add this line if you want to force a UI refresh
  }
}

function populateRunners() {
  const dropdowns = document.querySelectorAll(".runner-dropdown");
  const minuteInputs = document.querySelectorAll(".runner-minutes");
  const secondInputs = document.querySelectorAll(".runner-seconds");
  const dfactorInputs = document.querySelectorAll(".runner-dfactor");

  // Collect predictions from the Team Predictions table
  const runners = Array.from(dropdowns).map((dropdown, index) => {
    return {
      name: dropdown.value.trim(),
      minutes: parseInt(minuteInputs[index].value) || 0,
      seconds: parseInt(secondInputs[index].value) || 0,
      dfactor: parseFloat(dfactorInputs[index].value) || 1, // Default D Factor is 1
      laps: 0 // Track the number of laps for each runner
    };
  }).filter(runner => runner.name); // Filter out empty rows

  console.log("Collected Runners:", runners);

  const raceTableBody = document.querySelector("#raceTable tbody");
  const rows = raceTableBody.querySelectorAll("tr");

  let cumulativeSeconds = parseTime(document.getElementById("cumulativeTime").textContent); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Determine the starting index for predictions
  let startIndex = 0;

  // Check for the last fixed-prediction row
  const lastFixedRow = Array.from(rows).reverse().find(row => row.hasAttribute("data-fixed-prediction"));
  if (lastFixedRow) {
    const lastRunnerName = lastFixedRow.querySelector(".runner-field")?.value.trim();
    startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
    if (startIndex >= runners.length) {
      startIndex = 0; // Wrap around to the beginning
    }
  } else {
    // Fallback to the most recent completed runner if no fixed predictions exist
    const lastCompletedRow = Array.from(rows).reverse().find(row => row.querySelector(".lap-complete")?.checked);
    if (lastCompletedRow) {
      const lastRunnerName = lastCompletedRow.querySelector(".runner-field")?.value.trim();
      startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
      if (startIndex >= runners.length) {
        startIndex = 0; // Wrap around to the beginning
      }
    }
  }

  console.log(`Starting predictions from index: ${startIndex}`);

  let runnerIndex = startIndex; // Start predictions after the last fixed-prediction or completed runner

  rows.forEach((row, index) => {
    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const startTimeCell = row.querySelector(".start-time");
    const totalTimeCell = row.querySelector(".total-time");
    const paceCell = row.querySelector(".pace-cell");
    const checkbox = row.querySelector(".lap-complete");

    if (!checkbox.checked && runnerField && !row.hasAttribute("data-fixed-prediction")) {
      // Only populate rows that are not marked as completed and are not fixed predictions
      const runner = runners[runnerIndex % runners.length];
      if (runner) {
        runnerField.value = runner.name;

        // Calculate lap time
        let lapSeconds = runner.minutes * 60 + runner.seconds;
        if (runner.laps > 0) { // Apply D Factor only for laps after the first
          lapSeconds = Math.round(lapSeconds * runner.dfactor);
        }

        const hh = String(Math.floor(lapSeconds / 3600)).padStart(2, '0');
        const mm = String(Math.floor((lapSeconds % 3600) / 60)).padStart(2, '0');
        const ss = String(lapSeconds % 60).padStart(2, '0');
        laptimeField.value = `${hh}:${mm}:${ss}`;

        // Update cumulative time
        const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
        startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

        cumulativeSeconds += lapSeconds;
        totalTimeCell.textContent = formatTime(cumulativeSeconds);

        // Calculate pace
        if (lapSeconds > 0) {
          const pacePerKm = lapSeconds / 8; // Assuming 8 km per lap
          const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
          const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
          paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
        } else {
          paceCell.textContent = "-";
        }

        // Update runner's predicted time for the next lap
        runner.minutes = Math.floor(lapSeconds / 60);
        runner.seconds = lapSeconds % 60;

        runner.laps++; // Increment the lap count for the runner
        runnerIndex++;
      }
    }
  });

  updateTimes(); // Recalculate times for all rows
}

function highlightNextLapRow() {
  const rows = document.querySelectorAll("#raceTable tbody tr");
  let currentLapFound = false;

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Preserve the "completed" class while removing "next-lap"
    if (!row.classList.contains("completed")) {
      row.classList.remove("next-lap");
    }

    if (row.classList.contains("highlight-current")) {
      currentLapFound = true; // Mark the current lap as found
    } else if (currentLapFound && !checkbox.checked) {
      row.classList.add("next-lap"); // Apply the "next-lap" class to the next lap
      currentLapFound = false; // Stop after marking the next lap
    }
  });
}

// Call the function periodically to update the next lap
setInterval(highlightNextLapRow, 1000);

function applyFixUpToRow(checkbox) {
  const row = checkbox.closest("tr");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const index = rows.indexOf(row);

  rows.forEach((r, i) => {
    if (i <= index) {
      r.setAttribute("data-fixed-prediction", "true");
      const fixBox = r.querySelector(".fix-row");
      if (fixBox) fixBox.checked = true;
    } else {
      r.removeAttribute("data-fixed-prediction");
      const fixBox = r.querySelector(".fix-row");
      if (fixBox) fixBox.checked = false;
    }
  });

  saveData();
}

</script>

</body>
</html>
