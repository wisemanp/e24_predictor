<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Endure24 Race Timing - The Graveyard Swift</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 20px;
    background-color: #111; /* Black background */
    color: #e6e6e6; /* Light text */
    font-size: 1rem;
  }

  h1, h2 {
    color: #fff; /* White headings for contrast */
    font-size: 2rem;
    text-shadow: 0 2px 8px #5c068c;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 30px;
    background-color: #181828; /* Very dark for tables */
    border: 2px solid #5c068c; /* Purple outline */
    box-shadow: 0 4px 16px rgba(92,6,140,0.2);
  }

  th, td {
    border: 1px solid #5c068c; /* Purple cell borders */
    padding: 8px;
    text-align: center;
  }

  th {
    background-color: #181828;
    color: #c1a0da;
    border-bottom: 2px solid #5c068c;
  }

  input[type="number"],
  input[type="text"] {
    width: 90%;
    padding: 4px;
    border: 1px solid #5c068c;
    border-radius: 4px;
    background: #181828;
    color: #e6e6e6;
  }

  select {
    background: #181828;
    color: #e6e6e6;
    border: 1px solid #5c068c;
    border-radius: 4px;
    padding: 4px;
  }

  button {
    padding: 6px 12px;
    font-size: 14px;
    height: auto;
    background-color: #181828;
    color: #c1a0da;
    border: 2px solid #5c068c;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 2px 8px rgba(92,6,140,0.2);
    transition: background 0.2s, color 0.2s;
  }

  button:hover {
    background-color: #5c068c;
    color: #fff;
  }

  footer {
    margin-top: 40px;
    font-size: 0.9em;
    color: #aaa;
    text-align: center;
  }

  .completed {
    background-color: #281636 !important; /* Muted green for completed */
    color: #fff;
  }

  .race-header {
    display: flex;
    justify-content: flex-start;
    margin-top: 20px;
    font-size: 1.5em;
    font-weight: bold;
    color: #fff;
    border-left: 6px solid #5c068c;
    border-top: 2px solid #5c068c;
    border-radius: 8px 8px 0 0;
    background: linear-gradient(90deg, #5c068c 0px, #181828 40px);
    padding-left: 12px;
    margin-bottom: 0;
  }

  .greyed-out {
    background-color: #222 !important;
    color: #888;
  }

  .hidden-table {
    display: none;
  }

  #raceTable thead th {
    position: sticky;
    top: 0;
    background-color: #181828;
    color: #fff;
    z-index: 1;
    border-bottom: 2px solid #5c068c;
  }

  #runnerCountdowns {
  position: sticky;
  top: 0;
  z-index: 100;
  background-color: #181828;
  padding-top: 4px;
  padding-bottom: 4px;
}

  .team-container {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    background-color: #181828;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(92,6,140,0.2);
    border: 2px solid #5c068c;
  }

  #teamPredictions th:first-child,
  #teamPredictions td:first-child {
    width: 120px;
    white-space: nowrap;
  }

  #runnerCountdowns {
  display: flex;
  flex-wrap: nowrap;
  gap: 0;
  width: 100%;
  max-width: 100vw;
  position: sticky;
  top: 0;
  z-index: 100;
  background-color: #181828;
  padding: 0;
  margin: 0;
  border: 2px solid #5c068c;
  box-shadow: 0 4px 16px rgba(92,6,140,0.2);
}

  .runner-timer {
  flex: 1 1 0;
  min-width: 0; /* Allow infinite shrinking */
  max-width: 100%;
  box-sizing: border-box;
  margin: 0;
  padding: 16px 4px;
  font-size: 1.2em;
  border-left: 1px solid #5c068c;
  border-right: 1px solid #5c068c;
  border-top: none;
  border-bottom: none;
  background-color: #181828;
  color: #e6e6e6;
  text-align: center;
  font-weight: bold;
  display: flex;
  flex-direction: column;
  justify-content: center;
  border-radius: 0;
  transition: background 0.2s, color 0.2s;
}

/* Remove border on first and last for clean edges */
.runner-timer:first-child {
  border-left: none;
}
.runner-timer:last-child {
  border-right: none;
}

/* Keep all highlight/urgent/warning/next-to-run coloring */
.runner-timer.warning {
  background-color: #bfae5e !important;
  color: #2a203a;
}
.runner-timer.urgent {
  background-color: #a34d5c !important;
  color: #fff;
}
.runner-timer.on-course {
  background-color: #5c068c !important;
  color: #fff;
}
.runner-timer.next-to-run {
  background-color: #bbb !important;
  color: #2a203a;
  border: 2px solid #5c068c;
}
.runner-timer .on-course-label,
.runner-timer .next-to-run-label {
  font-size: 0.9em;
  font-weight: bold;
  margin-top: 4px;
}

/* Responsive: stack vertically on very small screens */
@media (max-width: 600px) {
  #runnerCountdowns {
    flex-direction: column;
    width: 100vw;
    max-width: 100vw;
  }
  .runner-timer {
    max-width: 100vw;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid #5c068c;
  }
  .runner-timer:last-child {
    border-bottom: none;
  }
}

  @media (max-width: 768px) {
    body {
      padding: 10px;
    }
    table {
      width: 100%;
      font-size: 0.9em;
    }
    .team-container {
      flex-direction: column;
      padding: 5px;
    }
    .runner-timer {
      font-size: 0.9em;
      padding: 5px;
    }
    button {
      font-size: 12px;
      padding: 4px 8px;
    }
  }

  /* Stack vertically on small screens */
  @media (max-width: 900px) {
    #runnerCountdowns {
      flex-direction: row;
      flex-wrap: wrap;
      gap: 2px;
      padding: 2px;
    }
    .runner-timer {
      font-size: 0.75em;
      min-width: 70px;
      max-width: 110px;
      padding: 2px 1px;
    }
  }

  #runnerCountdowns h2 {
  display: none;
}
.countdowns-only #runnerCountdowns {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  gap: 2px;
  width: 100vw;
  max-width: 100vw;
}
.countdowns-only #runnerCountdowns .runner-timer {
  flex: 1 1 320px; /* or 200px or whatever minimum width you want */
  min-width: 180px;
  max-width: 100vw;
  font-size: 1.8em;
  padding: 40px 8px;
  transition: font-size 0.2s, padding 0.2s;
  box-sizing: border-box;
}

.highlight-current {
  border-left: 6px solid #fff !important;
  border-right: 2px solid #fff !important;
  border-bottom: 2px solid #fff !important;
  border-top: 2px solid #fff !important;
  background-color: #5c068c !important;
  color: #fff;
}

.next-lap {
  background-color: #bbb !important;
  color: #5c068c;
  font-weight: bold;
  border-left: 6px solid #bfae5e !important;
}

/* Make urgent/warning always override next-to-run */
.runner-timer.next-to-run.urgent,
.runner-timer.urgent {
  background-color: #a34d5c !important;
  color: #fff !important;
}

.runner-timer.next-to-run.warning,
.runner-timer.warning {
  background-color: #bfae5e !important;
  color: #2a203a !important;
}

.runner-color-tag {
  display: inline-block;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  margin-right: 6px;
  vertical-align: middle;
  border: 2px solid #222;
  background-color: #ccc; /* fallback */
}

.single-countdown-mode {
  overflow: hidden;
}

.single-countdown-mode #runnerCountdowns {
  position: fixed !important;
  top: 0; left: 0; right: 0; bottom: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1000;
  margin: 0;
  padding: 0;
  display: flex !important;
  align-items: stretch;
  justify-content: stretch;
  background: none !important; /* Let the timer's background show */
}

.single-countdown-mode .runner-timer {
  display: none !important;
}

.single-countdown-mode .runner-timer.single-visible {
  display: flex !important;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  min-height: 100vh;
  min-width: 100vw;
  font-size: 7vw;
  margin: 0;
  padding: 0;
  position: static;
  /* DO NOT override background or color here! */
  border: none;
  box-shadow: none;
  text-align: center;
  line-height: 1.1;
}

@media (max-width: 600px) {
  .single-countdown-mode .runner-timer.single-visible {
    font-size: 12vw;
    padding: 0;
  }
  .single-countdown-mode #exitSingleBtn {
    font-size: 1em;
    padding: 8px 12px;
    top: 10px;
    left: 10px;
  }
}
</style>
</head>
<body onload="loadData()">
{% load static dict_get %}
<button onclick="exitSingleCountdown()" id="exitSingleBtn"  style="display:none;position:fixed;top:24px;left:24px;z-index:2001;background:#5c068c;color:#fff;font-size:1.2em;padding:12px 24px;border-radius:8px;">
  Exit Full Screen
</button>
<form style="display: none;">{% csrf_token %}</form>
<div id="currentTimeClock" style="position:fixed;top:10px;right:20px;font-size:1.5em;color:#bfae5e;z-index:2000;"></div>
<span id="fixedLapCount" style="display: none;">{{ fixed_laps }}</span>

<h1>Endure24 Race Timing - The Graveyard Swift</h1>

<!-- Add this button somewhere at the top -->
<button id="toggleModeBtn" onclick="toggleMode()">Show Countdowns Only</button>
<span id="cumulativeTime" style="display: none;">{{ cumulative_time }}</span>
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
  <label for="singleRunnerSelect">Full Screen Countdown:</label>
  <select id="singleRunnerSelect" onchange="showSingleCountdown()">
    <option value="">-- Select Runner --</option>
    {% for runner in runners %}
      <option value="{{ runner.name }}">{{ runner.name }}</option>
    {% endfor %}
  </select>
</div>


<!-- Runner Countdown Section -->
<div id="runnerCountdowns" style="margin-bottom: 20px;">
  <h2>Next Lap Countdown</h2>
  {% for runner in runners %}
  <div class="runner-timer" data-runner-index="{{ forloop.counter0 }}">
    <div class="runner-name-display">{{ runner.name }}</div>
    <div class="runner-countdown-value">--:--:--</div>
    <div class="on-course-label"></div>
    <div class="next-to-run-label"></div>
  </div>
  {% endfor %}
</div>


<!-- Team Predictions Section -->
<div class="team-container">
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1px;">
    <h2 style="margin: 1;">Team Predictions</h2>
    <button type="button" onclick="confirmPopulate()">Populate Predictions</button>
    <button onclick="togglePredictionTable()">Hide/Show Team Predictions</button>
  </div>
  <div id="teamPredictionWrapper">
    <div style="margin-bottom: 10px;">
      <label for="lapCount">Lap Rows:</label>
      <input id="lapCount" min="1" onchange="generateLapRows(); saveData();" style="width: 60px;" type="number" value="30"/>
    </div>
    <table id="teamPredictions" style="width: 80%; margin-top: 0;">
      <thead>
        <tr>
          <th>Runner</th>
          <th>Predicted Minutes</th>
          <th>Predicted Seconds</th>
          <th>D Factor</th>
          <th>Pace (first lap)</th>
          <th>Time Lost (sec/lap)</th>
        </tr>
      </thead>
      <tbody>
        {% for runner in runners %}
        <tr>
          <td>
            <select class="runner-dropdown" onchange="saveData();">
              <option value="">Select Runner</option>
              {% for runner_option in runners %}
              <option value="{{ runner_option.name }}">{{ runner_option.name }}</option>
              {% endfor %}
            </select>
          </td>
          <td>
            <input type="number" class="runner-minutes" min="0" placeholder="Minutes" oninput="updatePace(this); saveData();">
          </td>
          <td>
            <input type="number" class="runner-seconds" min="0" max="59" placeholder="Seconds" oninput="updatePace(this); saveData();">
          </td>
          <td>
            <input type="number" class="runner-dfactor" min="1" step="0.01" placeholder="D Factor" value="1.05" oninput="updatePace(this); saveData();">
          </td>
          <td><span class="runner-pace">-</span></td>
          <td><span class="runner-time-lost">-</span></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>
<button onclick="savePredictionsToServer()">Save Predictions</button>
<button onclick="forceLoadPredictionsFromServer()">Load Shared Predictions</button>

<!-- Race Results Section -->
<div class="race-header">Race Results</div>
<table id="raceTable">
  <thead>
    <tr>
      <th>Lap</th>
      <th>Lap Start Time</th>
      <th>Runner</th>
      <th>Laptime</th>
      <th>Pace</th>
      <th>Total Time</th>
      <th>Lap Complete / Fix Predictions</th>
    </tr>
  </thead>
  <tbody>
    {% for lap in laps %}
    {% if lap.fixed %}
      <tr class="completed">
        <td>{{ lap.number }}</td>
        <td class="start-time">
          {% if lap.fixed %}
            {{ lap.start_time }}
          {% else %}
            <input type="text" class="start-time-input" value="{{ lap.start_time }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
          {% endif %}
        </td>
        <td>
          
          {{ lap.number }}
        </td>
        <td>
          {% if lap.fixed %}
            {{ lap.laptime }}
          {% else %}
            <input type="text" class="laptime" value="{{ lap.laptime }}" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();">
          {% endif %}
        </td>
        <td class="pace-cell">
          {% if lap.fixed %}
            {{ lap.pace }}
          {% else %}
            <span class="pace-cell">-</span>
          {% endif %}
        </td>
        <td class="total-time">
          {% if lap.fixed %}
            {{ lap.total_time }}
          {% else %}
            <span class="total-time">-</span>
          {% endif %}
        </td>
        <td>
          {% if lap.fixed %}
            <input type="checkbox" class="lap-complete" checked disabled>
          {% else %}
            <input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();">
          {% endif %}
          <input type="checkbox" class="fix-row" onchange="applyFixUpToRow(this)">
        </td>
        
      </tr>
    {% endif %}
    {% endfor %}
  </tbody>
</table>


<footer>
  <p>Data is saved locally in your browser's localStorage. It will persist across page reloads and browser restarts.</p>
</footer>

<script>
    function parseTime(str) {
      const parts = str.split(":").map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return 0;
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }

    function formatTime(seconds) {
      const hrs = String(Math.floor(seconds / 3600)).padStart(2, '0');
      seconds %= 3600;
      const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
      const secs = String(seconds % 60).padStart(2, '0');
      return `${hrs}:${mins}:${secs}`;
    }

    
function updateTimes() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Day 1 start time: 12:00:00

  const cutoffTime = new Date(baseTime.getTime() + 24 * 3600 * 1000); // 24 hours later: 12:00:00 Day 2

  rows.forEach((row) => {
    const laptimeInput = row.querySelector(".laptime");
    if (!laptimeInput) return;

    const totalTimeCell = row.querySelector(".total-time");
    const startTimeCell = row.querySelector(".start-time");
    const paceCell = row.querySelector(".pace-cell");

    const laptime = parseTime(laptimeInput.value);
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
    startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

    cumulativeSeconds += laptime;
    totalTimeCell.textContent = formatTime(cumulativeSeconds);

    console.log("Cumulative Time (seconds):", cumulativeSeconds);

    if (laptime > 0) {
      const pacePerKm = laptime / 8;
      const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
      const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
      paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
    } else {
      paceCell.textContent = "-";
    }

    // Apply greyed-out class if startTime is after cutoff
    if (startTime > cutoffTime) {
      row.classList.add("greyed-out");
    } else {
      row.classList.remove("greyed-out");
    }
  });
}


    function updatePace(inputEl) {
  const row = inputEl.closest("tr");
  const minutes = parseInt(row.querySelector(".runner-minutes").value) || 0;
  const seconds = parseInt(row.querySelector(".runner-seconds").value) || 0;
  const dfactor = parseFloat(row.querySelector(".runner-dfactor").value) || 1;
  const paceCell = row.querySelector(".runner-pace");
  const timeLostCell = row.querySelector(".runner-time-lost");

  // Calculate original lap time in seconds (no D-Factor)
  let baseSeconds = minutes * 60 + seconds;
  if (baseSeconds === 0) {
    paceCell.textContent = "-";
    timeLostCell.textContent = "-";
    return;
  }

  // Pace per km (no D-Factor)
  const paceSecondsPerKm = baseSeconds / 8;
  const paceMinutes = Math.floor(paceSecondsPerKm / 60);
  const paceSeconds = Math.round(paceSecondsPerKm % 60).toString().padStart(2, '0');
  paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;

  // Time lost per lap due to D-Factor
  const dLapSeconds = Math.round(baseSeconds * dfactor);
  const timeLost = dLapSeconds - baseSeconds;
  timeLostCell.textContent = timeLost > 0 ? `+${timeLost}` : "0";
}
    function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure you want to populate predictions?")) {
    populateRunners();
    saveData();
    loadData(); // <-- Add this line if you want to force a UI refresh
  }
}

    

    function toggleRowCompletion(checkbox) {
      const row = checkbox.closest("tr");
      if (checkbox.checked) {
        row.classList.add("completed"); // Add the "completed" class
        console.log(`Row ${row.rowIndex} marked as completed.`);
      } else {
        row.classList.remove("completed"); // Remove the "completed" class
        console.log(`Row ${row.rowIndex} not completed.`);
      }
    }

    

function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr);

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0);

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>
        
        ${i}
      </td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td>
        <input type="text" class="runner-field" placeholder="Runner">
      </td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td>
        <input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();">
        <input type="checkbox" class="fix-row" onchange="applyFixUpToRow(this)">
      </td>
    `;
    raceTableBody.appendChild(row);

    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
  </script>
<script>
setInterval(updateCountdowns, 1000);
function highlightPreviousLapRow() {
  const now = new Date();
  let closestNegativeDiff = -Infinity;
  let closestRow = null;

  document.querySelectorAll("#raceTable tbody tr").forEach(row => {
    const startTimeCell = row.querySelector(".start-time");
    if (startTimeCell && startTimeCell.textContent.includes(":")) {
      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);
      const start = new Date();
      start.setHours(h, m, s, 0);
      const diff = start - now;
      if (diff < 0 && diff > closestNegativeDiff) {
        closestNegativeDiff = diff;
        closestRow = row;
      }
    }

    // Preserve the "completed" class while removing "highlight-current"
    if (!row.classList.contains("completed")) {
      row.classList.remove("highlight-current");
    }
  });

  if (closestRow) {
    closestRow.classList.add("highlight-current");
  }
}
setInterval(highlightPreviousLapRow, 1000);
function markRunnerOnCourse() {
  const highlightedRow = document.querySelector("#raceTable tbody tr.highlight-current");
  const countdownEls = document.querySelectorAll(".runner-timer");

  // Reset all runners
  countdownEls.forEach((el) => {
    el.classList.remove("on-course");
    el.querySelector(".on-course-label").textContent = "";
  });

  if (highlightedRow) {
    const runnerName = highlightedRow.querySelector(".runner-field")?.value.trim();

    countdownEls.forEach((el) => {
      const displayName = el.querySelector(".runner-name-display").textContent.trim();
      if (runnerName && displayName === runnerName) {
        el.classList.add("on-course");
        el.querySelector(".on-course-label").textContent = "On Course";
      }
    });
  }
}
setInterval(markRunnerOnCourse, 1000);
function markNextRunner() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  let minSeconds = Infinity;
  let nextRunner = null;

  countdownEls.forEach((el) => {
    el.classList.remove("next-to-run");
    el.querySelector(".next-to-run-label").textContent = "";

    const timeStr = el.querySelector(".runner-countdown-value").textContent;
    if (timeStr && timeStr.includes(":")) {
      const [h, m, s] = timeStr.split(":").map(Number);
      const total = h * 3600 + m * 60 + s;
      if (total < minSeconds) {
        minSeconds = total;
        nextRunner = el;
      }
    }
  });

  if (nextRunner) {
    nextRunner.classList.add("next-to-run");
    nextRunner.querySelector(".next-to-run-label").textContent = "Next to Run";
  }
}
setInterval(markNextRunner, 1000);

function updateCountdowns() {
  const countdownEls = document.querySelectorAll(".runner-timer");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const now = new Date();

  // Race start time (today at 12:00:00)
  const raceStart = new Date();
  raceStart.setHours(12, 0, 0, 0);

  countdownEls.forEach((timerEl) => {
    const runnerName = timerEl.querySelector(".runner-name-display").textContent.trim();
    let nextStart = null;

    for (const row of rows) {
      // Get runner for this row
      let rowRunner = "";
      if (row.querySelector(".runner-field")) {
        rowRunner = row.querySelector(".runner-field").value.trim();
      } else {
        rowRunner = row.children[2]?.textContent.trim();
      }

      if (rowRunner !== runnerName) continue;

      // Skip completed laps
      const checkbox = row.querySelector(".lap-complete");
      if (checkbox?.checked) continue;

      // Parse lap start time (hh:mm:ss)
      const startTimeCell = row.querySelector(".start-time");
      if (!startTimeCell || !startTimeCell.textContent.includes(":")) continue;

      const [h, m, s] = startTimeCell.textContent.split(":").map(Number);

      // Construct lap start Date object
      let lapStart = new Date(raceStart);
      lapStart.setHours(h, m, s, 0);

      // If lap time is before race start time (12:00), it means next day
      if (lapStart < raceStart) {
        lapStart.setDate(lapStart.getDate() + 1);
      }

      // If lapStart is in the future, that’s the next lap — break the loop
      if (lapStart > now) {
        nextStart = lapStart;
        break;
      }
    }

    // Update countdown display
    const displayEl = timerEl.querySelector(".runner-countdown-value");
    if (nextStart) {
      const diff = Math.floor((nextStart - now) / 1000);
      const hrs = String(Math.floor(diff / 3600)).padStart(2, "0");
      const mins = String(Math.floor((diff % 3600) / 60)).padStart(2, "0");
      const secs = String(diff % 60).padStart(2, "0");

      displayEl.textContent = `${hrs}:${mins}:${secs}`;
      updateCountdownColors(timerEl, diff);
    } else {
      displayEl.textContent = "--:--:--";
    }
  });
  sortCountdownsByTime();
}






function updateCountdownColors(timerEl, secondsLeft) {
  timerEl.classList.remove("urgent", "warning");
  if (secondsLeft < 600) { // Less than 10 minutes
    timerEl.classList.add("urgent");
  } else if (secondsLeft < 1800) { // Less than 30 minutes
    timerEl.classList.add("warning");
  }
}
function togglePredictionTable() {
      const wrapper = document.getElementById("teamPredictionWrapper");
      wrapper.classList.toggle("hidden-table");
    }

function applyCompletedClassOnLoad() {
  const rows = document.querySelectorAll("#raceTable tbody tr");

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Only toggle .completed for editable checkboxes (i.e., not fixed DB rows)
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });
}



// Call the function on page load
document.addEventListener("DOMContentLoaded", () => {
  applyCompletedClassOnLoad();
});
function saveData() {
  const fixedLaps = parseInt(document.getElementById("fixedLapCount")?.textContent) || 0;
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;

  // Only save editable rows (those with .runner-field)
  const editableRows = Array.from(document.querySelectorAll("#raceTable tbody tr"))
    .filter(row => row.querySelector(".runner-field"));

  const data = {
    lapCount: lapCount,
    predictions: Array.from(document.querySelectorAll("#teamPredictions tbody tr")).map(row => {
      const dropdown = row.querySelector(".runner-dropdown");
      const minutes = row.querySelector(".runner-minutes")?.value || 0;
      const seconds = row.querySelector(".runner-seconds")?.value || 0;
      const dfactor = row.querySelector(".runner-dfactor")?.value || 1;
      const runnerName = dropdown?.value || "";

      // Find the first editable race row with a matching runner name
      const raceRow = Array.from(document.querySelectorAll("#raceTable tbody tr"))
        .find(raceTr => {
          const runnerField = raceTr.querySelector(".runner-field");
          return runnerField && runnerField.value.trim() === runnerName;
        });

      const fixBox = raceRow?.querySelector(".fix-row");
      return {
        runner: runnerName,
        minutes: parseInt(minutes),
        seconds: parseInt(seconds),
        dfactor: parseFloat(dfactor),
        fixed: fixBox?.checked || false
      };
    }),
    race: editableRows.map((row, index) => {
      const runnerField = row.querySelector(".runner-field");
      const laptimeField = row.querySelector(".laptime");
      const checkbox = row.querySelector(".lap-complete");

      if (!runnerField || !laptimeField) return null;

      return {
        number: fixedLaps + index + 1,  // Offset lap number
        runner: runnerField.value,
        laptime: laptimeField.value,
        complete: checkbox?.checked || false,
        fixed_prediction: row.hasAttribute("data-fixed-prediction")
      };
    }).filter(row => row !== null)
  };

  localStorage.setItem("raceData", JSON.stringify(data));
}

function loadData() {
  const saved = localStorage.getItem("raceData");
  if (!saved) return;
  const data = JSON.parse(saved);

  // Restore lap count and generate rows
  if (data.lapCount) {
    const lapCountInput = document.getElementById("lapCount");
    if (lapCountInput) {
      lapCountInput.value = data.lapCount;
      generateLapRows(); // Ensure correct number of rows before restoring race data
    }
  }

  // Restore team predictions
  const predictionRows = document.querySelectorAll("#teamPredictions tbody tr");
  predictionRows.forEach((row, i) => {
    const dropdown = row.querySelector(".runner-dropdown");
    const minutesInput = row.querySelector(".runner-minutes");
    const secondsInput = row.querySelector(".runner-seconds");
    const dfactorInput = row.querySelector(".runner-dfactor");

    const savedPrediction = data.predictions[i];
    if (savedPrediction) {
      if (dropdown) dropdown.value = savedPrediction.runner;
      if (minutesInput) minutesInput.value = savedPrediction.minutes;
      if (secondsInput) secondsInput.value = savedPrediction.seconds;
      if (dfactorInput) dfactorInput.value = savedPrediction.dfactor;
      updatePace(minutesInput); // recalculate pace cell
    }
  });

  // Restore predicted race rows (skip fixed rows)
  const raceRows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  // Only editable rows (those with .runner-field input)
  const editableRows = raceRows.filter(row => row.querySelector(".runner-field"));

  data.race.forEach((lap, i) => {
    const row = editableRows[i];
    if (!row) return;

    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const checkbox = row.querySelector(".lap-complete");

    if (runnerField) runnerField.value = lap.runner;
    if (laptimeField) laptimeField.value = lap.laptime;
    if (checkbox && !checkbox.disabled) {
      checkbox.checked = lap.complete;
    }

    // Only set data-fixed-prediction on editable rows
    if (lap.fixed_prediction && runnerField) {
      row.setAttribute("data-fixed-prediction", "true");
      const fixBox = row.querySelector(".fix-row");
      if (fixBox) fixBox.checked = true;
    }

    // Only apply .completed class to editable rows
    if (checkbox && !checkbox.disabled) {
      row.classList.toggle("completed", checkbox.checked);
    }
  });

  updateTimes(); // refresh Start Time, Pace, Total Time
}


function generateLapRows() {
  const lapCount = parseInt(document.getElementById("lapCount")?.value) || 0;
  const raceTableBody = document.querySelector("#raceTable tbody");
  const currentRowCount = raceTableBody.querySelectorAll("tr").length;

  // Get the cumulative time after fixed laps from the hidden element
  const cumulativeTimeStr = document.getElementById("cumulativeTime").textContent;
  let cumulativeSeconds = parseTime(cumulativeTimeStr);

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0);

  // Add rows if the new lap count is greater than the current row count
  for (let i = currentRowCount + 1; i <= lapCount; i++) {
    const row = document.createElement("tr");
    const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);

    row.innerHTML = `
      <td>
        
        ${i}
      </td>
      <td class="start-time">${startTime.toTimeString().substring(0, 8)}</td>
      <td>
        <input type="text" class="runner-field" placeholder="Runner">
      </td>
      <td><input type="text" class="laptime" placeholder="HH:MM:SS" oninput="updateTimes(); saveData();"></td>
      <td class="pace-cell">-</td>
      <td class="total-time"></td>
      <td>
        <input type="checkbox" class="lap-complete" onchange="toggleRowCompletion(this); saveData();">
        <input type="checkbox" class="fix-row" onchange="applyFixUpToRow(this)">
      </td>
    `;
    raceTableBody.appendChild(row);

    cumulativeSeconds += 0;
  }

  // Remove rows if the new lap count is less than the current row count
  while (raceTableBody.querySelectorAll("tr").length > lapCount) {
    raceTableBody.removeChild(raceTableBody.lastChild);
  }

  setTimeout(updateTimes, 0);
}
function confirmPopulate() {
  console.log("Confirm Populate triggered");
  if (confirm("Are you sure you want to populate predictions?")) {
    populateRunners();
    saveData();
    loadData(); // <-- Add this line if you want to force a UI refresh
  }
}

function populateRunners() {
  const dropdowns = document.querySelectorAll(".runner-dropdown");
  const minuteInputs = document.querySelectorAll(".runner-minutes");
  const secondInputs = document.querySelectorAll(".runner-seconds");
  const dfactorInputs = document.querySelectorAll(".runner-dfactor");

  // Collect predictions from the Team Predictions table
  const runners = Array.from(dropdowns).map((dropdown, index) => {
    return {
      name: dropdown.value.trim(),
      minutes: parseInt(minuteInputs[index].value) || 0,
      seconds: parseInt(secondInputs[index].value) || 0,
      dfactor: parseFloat(dfactorInputs[index].value) || 1, // Default D Factor is 1
      laps: 0 // Track the number of laps for each runner
    };
  }).filter(runner => runner.name); // Filter out empty rows

  console.log("Collected Runners:", runners);

  const raceTableBody = document.querySelector("#raceTable tbody");
  const rows = raceTableBody.querySelectorAll("tr");

  let cumulativeSeconds = parseTime(document.getElementById("cumulativeTime").textContent); // Use cumulativeTime from the backend

  const baseTime = new Date();
  baseTime.setHours(12, 0, 0, 0); // Base start time: 12:00:00

  // Determine the starting index for predictions
  let startIndex = 0;

  // Check for the last fixed-prediction row
  const lastFixedRow = Array.from(rows).reverse().find(row => row.hasAttribute("data-fixed-prediction"));
  if (lastFixedRow) {
    const lastRunnerName = lastFixedRow.querySelector(".runner-field")?.value.trim();
    startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
    if (startIndex >= runners.length) {
      startIndex = 0; // Wrap around to the beginning
    }
  } else {
    // Fallback to the most recent completed runner if no fixed predictions exist
    const lastCompletedRow = Array.from(rows).reverse().find(row => row.querySelector(".lap-complete")?.checked);
    if (lastCompletedRow) {
      const lastRunnerName = lastCompletedRow.querySelector(".runner-field")?.value.trim();
      startIndex = runners.findIndex(runner => runner.name === lastRunnerName) + 1;
      if (startIndex >= runners.length) {
        startIndex = 0; // Wrap around to the beginning
      }
    }
  }

  console.log(`Starting predictions from index: ${startIndex}`);

  let runnerIndex = startIndex; // Start predictions after the last fixed-prediction or completed runner

  rows.forEach((row, index) => {
    const runnerField = row.querySelector(".runner-field");
    const laptimeField = row.querySelector(".laptime");
    const startTimeCell = row.querySelector(".start-time");
    const totalTimeCell = row.querySelector(".total-time");
    const paceCell = row.querySelector(".pace-cell");
    const checkbox = row.querySelector(".lap-complete");

    if (!checkbox.checked && runnerField && !row.hasAttribute("data-fixed-prediction")) {
      // Only populate rows that are not marked as completed and are not fixed predictions
      const runner = runners[runnerIndex % runners.length];
      if (runner) {
        runnerField.value = runner.name;

        // Calculate lap time
        let lapSeconds = runner.minutes * 60 + runner.seconds;
        if (runner.laps > 0) { // Apply D Factor only for laps after the first
          lapSeconds = Math.round(lapSeconds * runner.dfactor);
        }

        const hh = String(Math.floor(lapSeconds / 3600)).padStart(2, '0');
        const mm = String(Math.floor((lapSeconds % 3600) / 60)).padStart(2, '0');
        const ss = String(lapSeconds % 60).padStart(2, '0');
        laptimeField.value = `${hh}:${mm}:${ss}`;

        // Update cumulative time
        const startTime = new Date(baseTime.getTime() + cumulativeSeconds * 1000);
        startTimeCell.textContent = startTime.toTimeString().substring(0, 8);

        cumulativeSeconds += lapSeconds;
        totalTimeCell.textContent = formatTime(cumulativeSeconds);

        // Calculate pace
        if (lapSeconds > 0) {
          const pacePerKm = lapSeconds / 8; // Assuming 8 km per lap
          const paceMinutes = String(Math.floor(pacePerKm / 60)).padStart(2, "0");
          const paceSeconds = String(Math.round(pacePerKm % 60)).padStart(2, "0");
          paceCell.textContent = `${paceMinutes}:${paceSeconds}/km`;
        } else {
          paceCell.textContent = "-";
        }

        // Update runner's predicted time for the next lap
        runner.minutes = Math.floor(lapSeconds / 60);
        runner.seconds = lapSeconds % 60;

        runner.laps++; // Increment the lap count for the runner
        runnerIndex++;
      }
    }
  });

  updateTimes(); // Recalculate times for all rows
}

function highlightNextLapRow() {
  const rows = document.querySelectorAll("#raceTable tbody tr");
  let currentLapFound = false;

  rows.forEach((row) => {
    const checkbox = row.querySelector(".lap-complete");

    // Preserve the "completed" class while removing "next-lap"
    if (!row.classList.contains("completed")) {
      row.classList.remove("next-lap");
    }

    if (row.classList.contains("highlight-current")) {
      currentLapFound = true; // Mark the current lap as found
    } else if (currentLapFound && !checkbox.checked) {
      row.classList.add("next-lap"); // Apply the "next-lap" class to the next lap
      currentLapFound = false; // Stop after marking the next lap
    }
  });
}

// Call the function periodically to update the next lap
setInterval(highlightNextLapRow, 1000);

function applyFixUpToRow(checkbox) {
  const row = checkbox.closest("tr");
  const rows = Array.from(document.querySelectorAll("#raceTable tbody tr"));
  const index = rows.indexOf(row);

  if (checkbox.checked) {
    // Tick: fix all up to and including this row
    rows.forEach((r, i) => {
      if (i <= index) {
        r.setAttribute("data-fixed-prediction", "true");
        const fixBox = r.querySelector(".fix-row");
        if (fixBox) fixBox.checked = true;
      }
    });
  } else {
    // Untick: unfix this row and all after
    rows.forEach((r, i) => {
      if (i >= index) {
        r.removeAttribute("data-fixed-prediction");
        const fixBox = r.querySelector(".fix-row");
        if (fixBox) fixBox.checked = false;
      }
    });
  }

  saveData();
}

function sortCountdownsByTime() {
  const container = document.getElementById("runnerCountdowns");
  const timers = Array.from(container.querySelectorAll(".runner-timer"));

  timers.sort((a, b) => {
    const aTime = a.querySelector(".runner-countdown-value").textContent;
    const bTime = b.querySelector(".runner-countdown-value").textContent;

    // Convert --:--:-- to a large number so it sorts last
    const parse = (str) => {
      if (!str || str.includes('-')) return 999999;
      const [h, m, s] = str.split(":").map(Number);
      return h * 3600 + m * 60 + s;
    };

    return parse(aTime) - parse(bTime);
  });

  // Re-append in sorted order
  timers.forEach(timer => container.appendChild(timer));
}
// Add this JS to your script block
function toggleMode() {
  const countdowns = document.getElementById("runnerCountdowns");
  const teamPredictions = document.querySelector(".team-container");
  const raceTable = document.getElementById("raceTable");
  const btn = document.getElementById("toggleModeBtn");
  const body = document.body;

  if (btn.dataset.mode === "countdowns") {
    // Switch to full mode
    countdowns.style.display = "";
    teamPredictions.style.display = "";
    raceTable.style.display = "";
    btn.textContent = "Show Countdowns Only";
    btn.dataset.mode = "full";
    body.classList.remove("countdowns-only");
  } else {
    // Switch to countdowns only
    countdowns.style.display = "";
    teamPredictions.style.display = "none";
    raceTable.style.display = "none";
    btn.textContent = "Show Full Predictions";
    btn.dataset.mode = "countdowns";
    body.classList.add("countdowns-only");
  }
}

function savePredictionsToServer() {
  // Collect all editable, not-completed laps
  const predictions = Array.from(document.querySelectorAll("#raceTable tbody tr"))
    .filter(row => {
      const runnerField = row.querySelector(".runner-field");
      const completeBox = row.querySelector(".lap-complete");
      return runnerField && (!completeBox || !completeBox.checked);
    })
    .map(row => {
      const runnerField = row.querySelector(".runner-field");
      const laptimeField = row.querySelector(".laptime");
      const fixBox = row.querySelector(".fix-row");
      return {
        runner: runnerField?.value || "",
        laptime: laptimeField?.value || "",
        fixed: fixBox?.checked || false
      };
    });

  fetch('/save-predictions/', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({predictions: predictions})
  }).then(resp => resp.json()).then(data => {
    if (data.status === 'ok') {
      alert('Predicted laps saved!');
    }
  });
}
function loadPredictionsFromServer() {
  fetch('/load-predictions/')
    .then(resp => resp.json())
    .then(data => {
      if (data.predictions && data.predictions.length > 0) {
        // Only editable rows (those with .runner-field)
        const editableRows = Array.from(document.querySelectorAll("#raceTable tbody tr"))
          .filter(row => row.querySelector(".runner-field"));

        data.predictions.forEach((pred, i) => {
          const row = editableRows[i];
          if (!row) return;
          row.querySelector(".runner-field").value = pred.runner;
          row.querySelector(".laptime").value = pred.laptime;
          const fixBox = row.querySelector(".fix-row");
          if (fixBox) fixBox.checked = pred.fixed;
        });
      }
    });
}
document.addEventListener("DOMContentLoaded", loadPredictionsFromServer);
function forceLoadPredictionsFromServer() {
  fetch('/load-predictions/')
    .then(resp => resp.json())
    .then(data => {
      if (data.predictions && data.predictions.length > 0) {
        const editableRows = Array.from(document.querySelectorAll("#raceTable tbody tr"))
          .filter(row => row.querySelector(".runner-field"));

        data.predictions.forEach((pred, i) => {
          const row = editableRows[i];
          if (!row) return;
          row.querySelector(".runner-field").value = pred.runner;
          row.querySelector(".laptime").value = pred.laptime;
          const fixBox = row.querySelector(".fix-row");
          if (fixBox) fixBox.checked = pred.fixed;
        });
        // Overwrite localStorage with the loaded predictions
        saveData();
      }
    });
}

function showSingleCountdown() {
  const select = document.getElementById("singleRunnerSelect");
  const runnerName = select.value;
  const body = document.body;
  const timers = document.querySelectorAll(".runner-timer");
  const exitBtn = document.getElementById("exitSingleBtn");

  if (runnerName) {
    body.classList.add("single-countdown-mode");
    timers.forEach(timer => {
      const name = timer.querySelector(".runner-name-display").textContent.trim();
      timer.classList.toggle("single-visible", name === runnerName);
    });
    exitBtn.style.display = "inline-block";
  } else {
    exitSingleCountdown();
  }
}

function exitSingleCountdown() {
  document.body.classList.remove("single-countdown-mode");
  document.getElementById("singleRunnerSelect").value = "";
  document.querySelectorAll(".runner-timer").forEach(timer => timer.classList.remove("single-visible"));
  document.getElementById("exitSingleBtn").style.display = "none";
}
function updateCurrentTimeClock() {
  const el = document.getElementById("currentTimeClock");
  const now = new Date();
  el.textContent = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
}
setInterval(updateCurrentTimeClock, 1000);
updateCurrentTimeClock();
</script>



</body>
</html>
